# Опис Діаграми Послідовності (Sequence Diagram)

## 1. Загальна інформація
* **Назва сценарію:** Оформлення замовлення (Place Order).
* **Ідентифікатор Use Case:** `UC6`.
* **Основні вимоги (FR):**
  * `FR6` (Оформлення);
  * `FR5` (Робота з кошиком);
  * `FR3` (Пошук/Наявність);
  * `FR13` (Керування товарами - списання).

Ця діаграма моделює динамічну взаємодію між компонентами системи під час процесу купівлі товарів. Сценарій охоплює повний цикл: від ініціації запиту користувачем до фінального підтвердження оплати та бронювання товару на складі.

---

## 2. Учасники взаємодії (Participants)
Архітектура системи побудована на принципах сервіс-орієнтованої архітектури (SOA) або мікросервісів для забезпечення масштабування та розподілу відповідальності.

* **User (Користувач):** Ініціатор процесу.
* **Web Store (Frontend):** Клієнтський інтерфейс, що забезпечує взаємодію з користувачем (відповідає `NFR1`, `NFR5`).
* **Order Service (Backend Orchestrator):** Центральний сервіс, що керує бізнес-логікою замовлення. Він координує роботу інших сервісів, але не зберігає дані про залишки товарів самостійно.
* **Inventory Service (Складська система):** Автономний сервіс, відповідальний за перевірку наявності товарів та їх резервування (*Locking*). Забезпечує актуальність даних для `FR3` та `FR13`.
* **Payment Gateway (External System):** Зовнішня платіжна система (наприклад, LiqPay, Stripe). Винесена за межі внутрішнього контуру для відповідності стандартам безпеки (PCI DSS).
* **Notification Service:** Сервіс для асинхронної відправки повідомлень (Email/SMS), щоб не блокувати основний потік виконання.
* **Shared Database:** Сховище даних, що забезпечує транзакційність операцій.

---

## 3. Логіка виконання сценарію (Workflow)
Процес виконується за схемою **Two-Phase Commit** (логічний аналог) для забезпечення узгодженості даних між складом та оплатою.

### Основний потік (Happy Path):
1. **Ініціалізація:** Користувач підтверджує кошик. `Web Store` передає дані в `Order Service`.
2. **Резервування (Reservation):**
   * `Order Service` звертається до `Inventory Service` для кожного товару.
   * Виконується перевірка наявності та тимчасове блокування товару (*soft reserve*), щоб уникнути ситуації "Overselling" (продаж товару, який купують одночасно кілька людей).
3. **Оплата (Payment Processing):**
   * Після успішного резерву система перенаправляє запит до `Payment Gateway`.
   * Обробка чутливих платіжних даних відбувається на стороні провайдера.
4. **Фіксація (Commit):**
   * Отримавши підтвердження успішної оплати, `Order Service` зберігає замовлення зі статусом `PAID` у базі даних.
   * Відправляється команда в `Inventory Service` на остаточне списання товару (*hard commit*).
5. **Сповіщення:** `Notification Service` відправляє користувачу чек та деталі замовлення.

### Альтернативні потоки (Alternative Flows):
* **Сценарій А: Товар відсутній (Out of Stock):**
  * Якщо `Inventory Service` повертає помилку під час резервування, процес негайно переривається.
  * Користувачу відображається повідомлення про помилку, оплата не ініціюється.
* **Сценарій Б: Помилка оплати (Payment Declined):**
  * Якщо банк відхиляє транзакцію (недостатньо коштів тощо), `Order Service` ініціює **компенсуючу транзакцію** (*Compensating Transaction*).
  * Відправляється запит `releaseReservation` у складський сервіс, щоб розблокувати товари та повернути їх у продаж.

---

## 4. Ключові архітектурні рішення
* **Слабка зв'язність (Low Coupling):** Сервіс замовлень не знає внутрішньої логіки складу, він лише споживає його API.
* **Атомарність:** Використання механізму резервування гарантує, що товар не буде списаний, якщо оплата не пройшла.
* **Асинхронність:** Відправка email винесена в окремий виклик, щоб прискорити відповідь інтерфейсу користувачеві.